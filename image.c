#include "embroidery.h"

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

/* PPM Images
 * ----------
 *
 * Basic read/write support for images, so we can convert
 * to any other format we need using imagemagick.
 *
 * We only support P3 ASCII ppm, that is the original, 8 bits per channel.
 *
 * This also allows support for making animations using ffmpeg/avconv
 * of the stitching process.
 */

EmbImage * create_image(int width, int height, EmbColor background)
{
    int i;
    EmbImage *image;
    image = (EmbImage*)malloc(sizeof(EmbImage));
    image->width = 10.0;
    image->height = 10.0;
    image->pixel_width = width;
    image->pixel_height = height;
    image->color = (EmbColor*)malloc(sizeof(EmbColor)*width*height);
    for (i=0; i<width*height; i++) {
        image->color[i].r = 255;
        image->color[i].g = 255;
        image->color[i].b = 255;
    }
    return image;
}

/*
 */
int read_ppm_image(char *fname, EmbImage *a)
{
    int i, state;
    FILE *f;
    char header[2];
    f = fopen(fname, "r");
    if (!f) {
        return 0;
    }
    a->pixel_width = 100;
    a->pixel_height = 75;
    state = 0;
    while (fread(header, 1, 1, f) == 1) {
        /* state machine for dealing with the header */
        if (header[0] == '\n') {
            state++;
        }
        if (state == 4) {
            break;
        }
    }
    for (i=0; i<a->pixel_width * a->pixel_height; i++) {
        embColor_read(f, &(a->color[i]), 3);
    }
    fclose(f);
    return 1;
}


/*
 * This function should work, combine with:
 *    $ convert example.ppm example.png
 */
void write_ppm_image(char *fname, EmbImage *a)
{
    int i, j;
    FILE *f;
    char header[100];
    f = fopen(fname, "w");
    if (!f) {
        printf("Failed to open file: %s\n", fname);
        return;
    }
    sprintf(header, "P3\n# Generated by libembroidery 0.1\n%d %d\n%d\n", a->pixel_width, a->pixel_height, 255);
    fputs(header, f);
    for (i=0; i<a->pixel_height; i++) {
        for (j=0; j<a->pixel_width; j++) {
            fprintf(f, "%d %d %d ",
                a->color[j+i*a->pixel_width].r,
                a->color[j+i*a->pixel_width].g,
                a->color[j+i*a->pixel_width].b);
        }
        fprintf(f, "\n");
    }
    fclose(f);
}


/*
 *
 */
float image_diff(EmbImage *a, EmbImage* b)
{
    int i, j;
    float total;
    total = 0.0;
    for (i=0; i<a->pixel_width; i++) {
        for (j=0; j<a->pixel_height; j++) {
            total += embColor_distance(
                a->color[i+j*a->pixel_width],
                b->color[i+j*b->pixel_width]
            );
        }
    }
    return total;
}

/* Render Line
 * -----------
 * 
 */

int render_line(EmbLine line, EmbImage *image, EmbColor color) {
    EmbVector diff;
    EmbVector pos;
    int i;
    float pix_w, pix_h;
    diff.x = line.x2-line.x1;
    diff.y = line.y2-line.y1;
    pix_w = image->width / image->pixel_width;
    pix_h = image->height / image->pixel_height;
    for (i = 0; i < 1000; i++) {
        int x, y;
        pos.x = line.x1 + 0.001*i*diff.x + 10.0;
        pos.y = line.y1 + 0.001*i*diff.y;
        x = (int)round(pos.x / pix_w);
        y = (int)round(pos.y / pix_h);
        if (x >= 0 && x < image->pixel_width)
        if (y >= 0 && y < image->pixel_height) {
            image->color[x+y*image->pixel_width] = color;
        }
    }
    return 1;
}

/* Basic Render
 * ------------
 * This is a simple algorithm that steps through the stitches and
 * then for each line calls render_line.
 *
 * The caller is responsible for the memory in p and image.
 */

int render(EmbPattern *p, EmbImage *image, char *fname) {
    int i;
    EmbColor black = {0, 0, 0};
    EmbColor white = {255, 255, 255};
    image = create_image(100, 100, white);
    for (i=1; i < p->stitchList->count; i++)  {
        EmbLine line;
        line.x1 = p->stitchList->stitch[i-1].x;
        line.y1 = p->stitchList->stitch[i-1].y;
        line.x2 = p->stitchList->stitch[i].x;
        line.y2 = p->stitchList->stitch[i].y;
        render_line(line, image, black); /* HACK: st.color); */
    }
    write_ppm_image(fname, image);
    free(image);
    return 1;
}

/* EPS style render
 *
 *
 */

int render_postscript(EmbPattern *pattern, EmbImage *image) {
    return 1;
}

